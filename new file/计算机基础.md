# 计算机基础--组成原理

## 1.计算机组成原理

### 1.计算机的分类--背景篇

计算机可以分为5类：

超级计算机：

例如： 神威太湖之光，天河2号，天河1号 

【应用场所：在尖端科研领域提供算力  运算速度以TFlop/s为单位。普通个人计算机是GFlop/s为单位】

大型计算机：

应用于证券交易所，石油勘探，08年以前的阿里巴巴

主要制造公司是IBM，有专门的编程语言。

08年阿里巴巴提出了去“IOE”行动，09年创建了阿里云。“IOE”指的是IBM的大型机,Oracle的Oracle数据库,EMC的存储设备

将集中式架构变成了分布式架构

【算力比超级计算机低】

迷你计算机(服务器)

也就是服务器，国内主要厂商是联想，华为，浪潮。

【在大多数企业中已经通过服务器集群可以代替大型机】

工作站

影视工作者们常用的提高生产力工具。性能和个人计算机还是有明显的界线差别。 

个人计算机

常用的电脑。分为一体机，台式机，笔记本电脑



5类计算机价格由低到高

****

****

### 2.计算机的体系与结构--背景篇



**冯诺依曼体系：**

**将程序指令和数据一起存储的计算机设计概念结构**

将程序存储起来，同时设计的是通用电路。当我们需要运行某种程序的时候，先将这段程序翻译成电路能够理解语言，然后让通用电路去执行相关的逻辑。

**核心概念：存储程序指令，设计通用电路**



**冯诺依曼体系下的计算机的5大组件：**

1.必须有一个存储器

【存储要运行的程序，以及要程序运行所需要的数据】

2.必须有一个控制器

【因为我们需要存储程序，就需要知道执行到哪一步，下一步该执行什么程序。这一切的操作需要有一个控制器来控制流程】

3.必须有一个运算器

【负责完成运算的操作】

4.必须有一个输入设备

【输入数据】

5.必须有一个输出设备

【反馈结果】

**现代计算机都是冯诺依曼机。同时计算机领域的很多"轮子"都用的是冯诺依曼体系这种设计思想！**



**冯诺依曼机的功能：**

1.**能够把需要的程序和数据送至计算机中**

*这一点通过输入设备来实现*

2.**能够长期记忆程序、数据、中间结果及最终运算结果的能力** 

*这一点是依赖冯诺依曼机中的存储器来实现的*

3.**能够具备算术、逻辑运算和数据传送等数据加工处理的能力**

*由运算器和控制器所完成的*

**4.能够按照要求将处理结果输出给用户**

*这一点通过输入设备来实现的*

结构图：

![](C:\Users\fucker\Pictures\jc.2.PNG)

可以看到**控制器控制着着另外4个组件**。从输入设备传来的数据，**只经过运算器的直接处理。****数据由存储器或者运算器发送给输出设备**

**冯诺依曼瓶颈：**

产生原因：CPU和存储器是分开的

造成影响：CPU和存储器之间的问题无法调和。CPU处理速率很快，而存储器的处理速率相比较慢。这样就导致，**不断由CPU产生的新数据，存储器来不及存储。CPU因此经常空转等待数据的传输。这样非常浪费资源。**把CPU跑满才是充分利用计算机的表现。



**现代计算机的结构：**

（是什么？）概念：现代计算机是在冯诺依曼体系结构的基础上进行修改

（为什么？）**产生的原因：主要是为了解决CPU与存储设备之间的性能差异。**

（怎么样？）如何解决冯诺依曼瓶颈：**现代计算机的CPU=运算器+控制器+存储器    3者在同一块芯片上面。**

存储器(广义定义):可以存储设备的介质

一般说存储器，可能首先想到的是磁带和硬盘，但是**在CPU中的存储器指的是CPU的寄存器**，同时还有计算机的内存也是为了解决性能差异的。**两者都是围绕控制器和运算器的更高速的设备。**

因此现代计算机的结构可以理解为：**以存储器为核心**

****

---  ---

### 3.计算机的层次与编程语言--背景篇

1.程序翻译和程序解释

程序翻译：**将人类语言(英语，汉语等)翻译成计算机语言**（0101010111）

**需要进行语言之间的转换**
为了做到转换我们需要：

**1.较为高级的计算机语言，这里称之为L1**

**2.较为低级的计算机语言，这里称之为L0**

我们用L1 编写代码（**L1进行程序逻辑的描述**）然后**通过编译器生成逻辑等价的L0编写的代码（产生了新的程序）。**这里的L0是**计算机实际执行的语言**。我们**将L1生成L0称为程序翻译**



我们用L1编写代码（**L1进行程序逻辑的描述**，为了实现L1，我们还需要用L0实现 另外一个程序。而这个程序将L1作为输入进行执行（这个用L0写的程序我们称为解释器），**每一条L1语句都会被等价逻辑转化成L0所编写的代码（没有产生新的程序）**。我们将这个过程称为程序解释。



两者的区别与联系：

1.计算机执行的指令都是L0

2.**翻译过程生成新的L0程序，解释过程不生成新的L0程序**（它只是将L1代码输入到解释器中，然后解释器将其转化为L0代码。可以理解为点石成金）



常见的翻译性语言：C/C++   Object-C    Golang

常见的解释性语言：Python   PHP         JavaScript

**翻译+解释**：JAVA  C#

**why,java???**

**java先编译成JVM字节码，然后通过解释器变成机器码**

-- -



**2.计算机的层次与编程语言**

总共有7个层次：

7.应用层
6.高级语言层
5.汇编语言层
4.操作系统层
3.传统机器层
2.微程序机器层
1.硬件逻辑层

1、2、3三层属于实际机器层 ，而4、5、6、7这4层是虚拟机器层。同时虚拟机器还可以分为2个部分。5、6、7这三层属于系统软件，而应用层主要是应用软件。



**分开来看：**

1.硬件逻辑层：

**门、触发器等逻辑电路**

属于电子工程领域

2.微程序机器层：

编程语言是**微指令集**

**微指令所组成的微程序直接交由硬件执行**

3.传统机器层：

编程语言是**CPU指令集(机器指令)，它存储在CPU内部，对CPU的运算和优化 进行指导。**

在这一层，程序员所用机器指令编写的程序，可以交由微程序直接进行解释执行。

编程语言和硬件是直接相关。

**inter和AMD的最大区别也是在这里，它们所使用的指令集不同。同一个厂商也可以生成不同指令集的CPU，例如X86架构和X64架构**

不同架构的CPU使用不同指令集



**微指令、微程序、机器指令**三者之间的关系：

1.**一条机器指令对应着一个微程序**

2.**一个微程序对应着一组微指令**

总体来说：微指令<微程序=机器指令

-- -

4.操作系统层：

**向上提供了简易的操作界面**

**向下对接了指令系统，管理硬件资源**

**由此可见操作系统是在软件和硬件之间的适配层**



5.汇编语言层：

**编程语言是汇编语言**

汇编语言可以**翻译**成可直接执行的机器语言

完成翻译的过程的就是汇编器

**从这层起，使用的编程语言都是人类比较容易理解的编程语言**

```汇编
PUSH DS
PUSH AX
MOV  AX,0040
MOV  DS,AX
```



6.高级语言层：

编程语言为主流程序员所接受的**高级语言**

高级语言的类别非常多，有几百多种

常见的高级语言有：Python,Java,C/C++,Golang等



7.应用层

满足计算机针对某种用途而专门设计

例如：ppt,word

**也可以把它理解为面向问题的应用语言**



最后，**分层的目的是便于理解，而不是固定的。今天的软件可能变成明天的硬件**

****

****

### 4.计算机的速度单位--背景篇



**1.容量单位**

**在物理层面，高低电平记录信息。高电平表示1，而低电平表示0**

**理论上只认识0/1两种状态**。这里的**0/1称为bit(比特位)**



0/1能够表示的内容太少了，需要更大的容量表示方法

因此有人就想到了用**8个bit来表示一个字节**

|          | bit    | byte  | kb     | MB       | GB        | TB     | PB     | EB       |
| -------- | ------ | ----- | ------ | -------- | --------- | ------ | ------ | -------- |
| 名字     | 比特位 | 字节  | 千字节 | 兆字节   | 吉字节    | 太字节 | 拍字节 | 艾字节   |
| 比例     | -      | 8byte | 1024b  | 1024MB   | 1024MB    | 1024GB | 1024TB | 1024EB   |
| 常见设备 | 门电路 | -     | 寄存器 | 高速缓存 | 内存/硬盘 | 硬盘   | 云硬盘 | 数据仓库 |



**1024=2^10**



**常见的习题：**

   1GB内存，可以存储多少字节的数据？可以存储多少比特的数据？
$$
1GB=1024MB=1024*1024KB=1024*1024*1024byte=8*1024*1024*10244bit
$$
~~1073741824byte   8,589,934,592bit~~

1GB=1024^3byte=8*1024^3bit



为什么买的500GB的移动硬盘，格式化后就只剩465G了

**硬盘商是10进制来标记容量的，他们眼中的1GB=1000MB，而不是1024MB**

**先化成bit,再由bit换为GB**
$$
500*1000^3/1024^3 =465
$$
容量换算的结果大约是465GB

**U盘中也是类似的。使用10进制位来标记容量是为了记录硬盘扇区，这里使用人类常用的十进制会更好理解和沟通。**



常见的2M宽度，10M宽带，100M宽度。这里的兆是否是容量单位？

**这里的100M并不是指容量单位，那100兆指的什么？？？**

**指的是100Mbps或者说是100Mbit/s，bit/s变成byte/s需要进行除8单位换算，100Mbit/s也就是12MByte/s **

****

2.速度单位

**网络速度单位**

为什么100M宽带，测试峰值速度只有12MB每秒？

**网络常用的单位为Mbps**，只是我们使用时，经常将其省略为M

也就是说：**100M/S=100Mbps=100Mbit/s=(100/8)MB/s=12.5MB/s**

**100M指的是Mbit/s而不是Mbyte/s,Mbyte/s简写为MB/S**



**CPU速度单位**

**CPU的速度一般体现为CPU的时钟频率**

**CPU的时钟频率的单位一般都是赫兹(Hz)**

主流CPU的时钟频率都在2GHz以上

**Hz其实就是秒分之一。它是每秒的周期性变动重复次数的计量**

常见的：蝴蝶翅膀振动的频率为每秒15次，也就是15Hz。而蜜蜂振动每秒可达400次，也就是400Hz。而我们人耳可以听见的声音的频率的范围为20~20000Hz

**我们知道CPU是用高低电平来表示0/1的，由0到1，由1到0这算是一次周期性变化。而计算机CPU就是在不断的做着这样的CPU变化。**

2GHz=2*1000^3Hz=每秒20亿次

主流的2GHz也就代表着CPU可以做着每秒20亿次高低电平的变换

****

****

### 5.计算机的字符与编码集--背景篇

**ACSII码**:

*7个**bit位(2进制中的位)**就可完全表示ACSII码*

*包含95个可打印字符*

*33个不可打印字符(包括控制字符)，在表的前两列(32个)，以及表的最后一个*

33+95 =128=2^7

这里的bit位，表示的是每一个bit表示一个ASCII码时，**表示完所有的ASCII码，所需要的bit数的位数。**

**bit位：表示完所有地址/方案/元素所需的bit的个数的个数**

*ACSII码表*



**extended ACS||码**

*由8bits代替了7bits。由于是8位，变成了256个字符*

扩充包括：

**常见的数学字符**

**带音标的欧洲字符**

其他常用的符,表格符



**字符编码集的国际化**

出现的原因：

*欧洲，中亚，东亚，拉丁美洲国际的语言的多样性*

*语言体系不一样，不以有限的字符组合的语言*

**以中国，韩国，日本的语言最为复杂**

****

**中文编码集**

**GB2312**：国标2312，**全称为《信息交换用汉字编码字符集—基本集》**

一共收录了7445个字符

包括了6763个汉字，以及682个其他符号

**GB2312需要多少bits?**
$$
1024*2=2048，2048*2=4096，4096*2=8192
$$
1024=2^10,8192=2^13

**GBK：全称《汉字内码拓展规范》 1995年推出**

*向下兼容了GB2312，向上支持了国际的ISO标准*

**收录了21003个汉字，支持了全部中日韩汉字**

**但这是本地的编码集，并不是国际化的编码。如果外国人本地用的不是GBK或者GB2312的编码集访问中文网站，就会出现乱码**

****

**兼容全球的字符集：Unicode**

**Unicode：统一码，万国码，单一码**

Unicode规定了世界通用的符号集，UTF-*实现编码

**UTF-8就是以1个字节(8个bit)为单位对Unicode进行编码**

**Unicode是字符集 ，UTF-8则是对进行编码之后的编码集**

**实际开发中推荐使用UTF-8来编码**

**Windows系统中文环境默认是GBK编码(它向下兼容GB2312，显示时可能是GB2312)，设置IDE时就需要将编码集改成UTF-8**

****

### 6.计算机的总线--组成篇

**(是什么？)总线的概述:**

USB**全称为通用串行总线**

*提供了对外连接的接口

*不同设备可以通过USB接口进行连接

*连接的标准，促使外围设备接口的统一

**除此之外，还有PCI总线（插显卡的），ISA总线，Thunderbolt总线等**

****

**（有什么用？/为什么要有总线？）总线的主要作用：解决不同设备的通信问题**

如果没有IO总线，5大设备各自分散连接，如果要新增一个输出设备就需要各自连接其他4个设备！

如果是IO总线，所有设备都连接在总线上面，以总线为核心。如果新增设备，直接连接在总线上面即可！**优点是简化结构的复杂度，使结构清晰，容易梳理**



**总线的分类：**

**片内总线：**

指的是CPU内的总线，**它连接的是高速缓存、控制器、中断系统、运算器**

*芯片内部的总线*

*连接寄存器与寄存器之间*

*寄存器与控制器、运算器之间*

总体来说，**片内总线：高集成度的芯片内部的信息传输线**

****

**系统总线：CPU、主内存、IO设备、各组件之间的信息传输线**

可以分为三类：

**数据总线：一般与CPU位数相同(32位，64位）**  【线上走的是数据信息】

*作用：双向传输各个部件的数据信息*

*数据总线的位数(总线宽度)是数据总线的重要参数。*如果是32位，那它一次就可以传32bits，也就是4个字节的数据。如果是64位则可以一次传8个字节的数据



**地址总线：指定源数据或目的数据在内存中的地址**  【线上走的是地址信息】

*作用：用于数据的寻址*

**地址总线的位数与存储单元的位数有关**

**地址总线位数=n,寻址范围0~2^n**





**控制总线**： 【线上走的是控制信息】

*作用：发出各种控制信号*

**控制信号经由控制总线从一个组件发给另一个组件**

*控制总线可以监视不同组件之间的状态(就绪/未就绪)* 。例如键盘是否就绪，如果就绪就可以使用它作为输入设备。



****

**总线的仲裁**

(为什么？) ***为什么要有总线的仲裁？***

**假设：**

主存需要和硬盘和IO设备交换数据，此时总线是该由硬盘还是该由IO设备使用？

这时就需要一个第3方的仲裁器！



出现的原因（回答那个问题）：**为了解决总线使用权冲突问题**





**总线仲裁方法**

1*.链式查询*：

![](C:\Users\fucker\Pictures\jc.4.png)

仲裁控制器通过仲裁控制线连接着设备。假如设备2需要使用总线，它需要先通过仲裁控制器向仲裁控制器发出总线使用的请求。然后仲裁器控制器释放出允许使用的信号。经过设备1时若是设备1也发出了请求，则最后优先使用设备的就是设备1，而不是设备2。



**好处：电路复杂度低，仲裁方式简单**

坏处：优先级的设备难以获得总线使用权。**设备的优先级就体现在链式查询中的先后顺序。**

坏处：对电路故障敏感(串联 电路都有)





2.**计时器定时查询**

![](C:\Users\fucker\Pictures\jc.5.PNG)



仲裁控制器给每一个设备都有一个编号。同时它自身有一个计数器，最开始是1，因此它向所有设备通过仲裁控制器发送计数值1。如果计数值与**发出仲裁信号**的**设备编号**相等，则该设备获得总线使用权。图中是设备2发出的信号。**当仲裁控制器发出计数值1的时候，设备1并没有发出仲裁信号，其他设备则是自身编号与计数值不相等**。此时的计数器累计计数，计数值由1变成了2，然后通过仲裁控制线向所有设备发送计数值2，此时设备2的编号与计数值2相等！因此设备2得到了总线使用权。如果此时设备3向仲裁控制器发送了请求，则下一次计数器使用时，又加1由2变成了3。然后下一次仲裁控制器向所有设备发送计数值3.



仲裁控制器对设备编号并使用计数器累计计数

接受到仲裁信号后，往所有设备发出计数值

计数值与发送仲裁信号的设备编号一致则获得总线使用权





**独立请求：**

每个设备均有总线独立连接仲裁器

设备可单独向仲裁器发送请求和接受请求

当同时收到多个请求信号，仲裁器有权按优先级分配使用权

![](C:\Users\fucker\Pictures\jc.6.PNG)

**好处：响应速度快，优先顺序可动态改变**

**坏处：设备连线多，总线控制相对复杂**

****

****

### 7.计算机是输入输出设备(IO设备)--组成篇

**常见的输入设备**

1.字符输入设备

最常见的就是键盘。

键盘可以分三种：

- 薄膜键盘：标配的主机一般都是薄膜键盘。**键盘内部由有弹性的薄膜连接起来**
- 机械键盘：**每一个键位都是由独立的轴连接起来的，敲击时，感觉会好很多。**机械键盘根据*段落感*，*声音*，*压力*，*键程*可以分为：黑轴，红轴，青轴，茶轴,樱桃轴。
- 电容键盘：比较高档



2.图形输入设备

最常见的是**鼠标**，**数位板**，**扫描仪**

数位板：主要包括输入板和压感笔。常用于绘图创作

扫描仪：**将图形信息转化为数字信号**

3.**图像输出**设备

主要有**显示器，打印机，投影仪**

显示器有两种：*CRT显示器、液晶显示器*

****

**输入输出接口的通用设计**

*如何设计输入输出接口？*

首先要**支持读取数据**，其次要能**向设备发送数据**，然后**处理设备是否被占用**，最后**判断设备是否已经连接，设备是否已经启动**



接口主要有： 【作用是和外设连接，并操作外设】

1.数据线：**I/O设备与主机之间进行数据交换的传输线**

*根据设备的区别，可以分为单向传输线、双向传输线*

2.状态线：**IO设备状态向主机报告的信号线**

*查询设备是否已经正常连接并就绪*

*查询设备是否已经被占用*

3.命令线：**CPU向设备发送命令的信号线**

**发送读写信号，发送启动停止信号。**例如主机中的光驱，计算机就是通过*命令线向光驱发动启动停止信号*

4.设备选择线：**主机选择I/O设备进行操作的信号线**

*对连在总线上的设备进行选择。*例如在对多个U盘进行选择，然后再进行读写操作，就是通过设备选择线。

****

**CPU与IO设备的通信**

**首先要了解：CPU速度与IO设备速度不一致**

1.**程序中断**

*当外围的IO设备准备就绪时，向CPU发送中断信号*

*CPU内部有专门的电路响应中断信号*

![](C:\Users\fucker\Pictures\jc.7.PNG)

**这里需要注意的是CPU响应中断，不是立即响应的，可能会有一定的延时！**

**提供低速设备通知CPU的一种异步方式**

因为有了程序中断**CPU可以在高速运转同时兼顾低速设备的响应**

【就像是通知CPU临时接个任务，任务资料准备就绪，CPU就停下手上的活，**来完成这个临时任务**。任务完成后又继续手上的工作】

**缺陷：频繁的打断CPU会降低CPU的使用效率**

**2.DMA(直接存储器访问)**

1.DMA直接连接主存和IO设备

2.DMA工作时不需要CPU的参与

![](C:\Users\fucker\Pictures\jc.8.PNG)

**当主存与IO设备交换信息时，不需要中断CPU**

通过DMA直接存储器访问，**可以大大提高CPU的效率**

*平时的硬盘和显卡中都有DMA设备**

****

### 8.计算机存储器的分类--组成篇

1.存储器的分类：

【按存储介质分类】

半导体存储器：内存，U盘，固态硬盘

磁性存储介质：磁带，磁盘

【按照存取方式分类】

**随机存储器(RAM) ：1.随机读取  2.与 位置无关**

串行存储器：1.与位置有关，2.按顺序查找  

**只读不写存储器(ROM)：只读不写**

****

2.存储器的层次结构

购买存储器考虑的因素：

读写速度：5400转、7200转

存储容量：2T，4G

价格

**为了量化存储器的性价比，有了位价**

**容量+价格=>位价 ：每比特位价格**

*我们可以根据位价和读写速度将存储器划分为几个层次：*

**缓存，主存，辅存**这3个层次    

缓存：CPU中的高速缓存和寄存器  **位价高 速度块 容量低**

主存：计算机中的内存    **位价中 速度中 容量中**

辅存：外部辅存设备。**例如磁盘，U盘，移动硬盘**    **位价低 速度慢 容量高**



**CPU和缓存、主存3者可以直接通信，我们把这个层次称为缓存-主存 层次。**

原理：**局部性原理**

实现：在CPU与内存之间增加一层速度快(容量小)的Cache(也就是高速缓存)

**目的：解决主存与CPU速度不匹配的问题**

局部性原理：局部性原理是指CPU访问存储器时，无论是**存取指令**还是**存取书**，所访问的存储单元都**趋近于聚集在一个较小的连续区域中。**

![](C:\Users\fucker\Pictures\jc.9.PNG)

**访问高速缓存这个较小的连续区域**，读写速度快速提高



**辅存只能与主存直接通信，CPU不参与，这个层次被称为主存-辅存层次。**

原理：局部性原理

实现：主存之外增加辅助存储器（磁盘、SD卡、U盘）

**目的：解决主存容量不足的问题**



**电脑中有一个20G的游戏，但是电脑内存只有8G，那游戏是这么运行起来的？**

根据局部性原理，*对应一些要使用的数据放入主存中，对于一些当前不使用的数据，放入辅存中。*

****

****

### 9.计算机的主存储器与辅助存储器--组成篇

思考：

**计算机断电，内存数据丢失？**

**计算机断电，磁盘数据不会丢失？**



**主存储器：内存(内存条)**

1.它是**RAM(随机存取存储器)**

2.RAM**通过电容存储数据，**每隔一端时间必须刷新一次

3.**如果掉电，那么一段时间后将丢失所有数据**

刷新必须要有电的存在，如果有一段时间不刷新则电容中的电子也会丢失，数据也就因此丢失了





**内存的组成**

![](C:\Users\fucker\Pictures\jc.10.PNG)

**地址总线：指定数据的位置**

**数据总线：传输数据**



**内存与操作系统的关系：**

*32位系统：*  2^32 =4^30 =4GB

这是32位系统的所能支持的最大内存，加更多的内存条也没有用，**因为它的地址总线只有32位，因此它的寻址范围只有4GB的大小**





*64位系统：*   2^64 =2^34*2^30 =2^34GB

**因为它的地址总线是32位，因此它的寻址范围有2^34GB**



****

**辅助存储器：磁盘**

![](C:\Users\fucker\Pictures\jc.11.PNG)

**盘片：磁材料存储数据**

**磁道：盘片一周的内容**

**扇区：磁道中一部分的内容**



![](C:\Users\fucker\Pictures\jc.12.PNG)

磁头的方向：例如磁头是**往里走**，还是**往外走**

磁头的位置：关注**磁头当前是位于哪一个方向的**





**磁盘的组成：**

1.*表面是可磁化的硬磁特性材料*

2.*移动磁头径向读取磁道信息*





**磁盘的调度算法：**

举例：

**这里我们把最外面的磁道称之为第1磁道，最里面的磁道称之为第5个磁道**

![](C:\Users\fucker\Pictures\jc.13.PNG)



**1.先来先服务算法：**【命令/需求的顺序】

按先后顺序访问的磁道读写的需求

![](C:\Users\fucker\Pictures\jc.14.PNG)

**磁头由磁道4，移向磁道1。每次读取时，都是磁头移动到 相应的磁道进行访问**



**2.最短寻道时间优先算法：**【一直访问的都是离磁头最近的】

*与磁头当前位置有关*

*优先访问离磁头最近的磁道*

![](C:\Users\fucker\Pictures\jc.15.PNG)

**首先是读取第4个磁道**，因为它是优先访问离磁头最近的磁道

*然后既可以是读取第5个磁道，也可以是读取第3个磁道*，两者距离第4个磁道 一样近



**3.扫描算法(电梯算法)：**【先是单向查找，然后反向查找】

*每次只往一个方向移动*(就和电梯一样，一次只能往一个方向载人)

*到达一个方向需要服务的尽头再反方向移动*

![](C:\Users\fucker\Pictures\jc.16.PNG)

这里它先读取当前磁头所在的磁道，也就是第4磁道

之后，**因为磁头的方向向外，再去读取的就是4磁道外侧的磁道，也就是第3磁道**，然后就是第2磁道，然后是第1磁道。**第1磁道读取2次，外侧已经到需要服务的尽头了，然后反方向读取到第2个磁道。。。直到移动到第5个磁道，读取第5个磁道。**





4.**循环扫描算法：**【永远单向查找，这个方向到头后，直接返回到初始方向进行查找】

**因为扫描算法并不公平，因此在它的基础上提出了循环扫描算法**

它和扫描算法最大的区别：**只向一个方向读取。**而扫描算法会出现 反方向方向读取

![](C:\Users\fucker\Pictures\jc.17.PNG)



**假设这里设定它由外向内读**

首先读取第4个磁道，然后是第5个磁道。到尽头了，直接将磁头移动到第1个磁道，然后开始读第1个磁道两次。然后第2个磁道，第3个磁道....**这里没有反向读取** 



****

****

### 10.计算机的高速缓存--组成篇



回顾一下前面的内容：

**高速缓存位于主存-缓存层，在CPU和主存之间**

解决的问题**：CPU与主存的速度不匹配**





**高速缓存的工作原理**

为了了解高速缓存的工作原理，**需要先了解一下主存中的一些概念：**

**字:【内存中的最小单元】**

*是指存放在一个存储单位中的二进制代码的组合*

一个字可以表示：**一个数据，一条指令，一个字符串**



**字块：【多个字连续组成一个字块】**

存储在连续的存储单元中而被看作是连续一个单元的一组字

**总字数*单一字位数=总容量**

假设：

一个字有32位   【这里是bit位，不是比特数！这里的32位是假设的，不代表实际 的，毕竟4GB一个字，太大了】

一个字块有B个字

主存共有M个字块

B*M	=主存总字数

总字数*32=主存总容量(bits)



有了字和字块就可以**理解寻址的过程：**

字的地址包括2个部分:

前m指的是字块的地址

后b位指定字在字块中的地址

![](C:\Users\fucker\Pictures\jc.18.PNG)

下面的例子可能好理解一点m和M的关系



![](C:\Users\fucker\Pictures\jc.19.PNG)

**所谓地址实际上是可以理解位序号：**【字块数、块内字数都一一对应着序号，也就对应着地址】

字块数有1024个，这里的字块地址也就有1024个，也就是1024个序号。

字块地址m，**实际上指的是代表地址的序号，出现的最大序号的位数**。1个表示1024的数，在二进制中有多少位。正如4在二进制中是2位一样，1024在二进制中是2^10，也就是2的10位。

同理，块内地址b,**指的也是代表块内地址的最大序号的位数**。这里最大序号是1048576，它在二进制中是2^20，也就是2的20位



**高速缓存的存储逻辑结构类似(字和字块，地址。且运算方式相同)**

*缓存的容量较小，速度较快*

**缓存中的数据都是复制主存得来**



**CPU有两种情况下需要高速缓存(工作原理)：**

CPU需要的数据在缓存里【直接拿】



CPU需要的速度不在缓存中：

**不在缓存需要去主存拿**

****

以下内容大致了解即可，因为没有涉及具体是如何访问的，如，*访问主存的同时也在访问高速缓存？*访问效率的公式并不易理解！掌握命中率(总次数中的xx)，知道有访问效率(缓存时间内的xx)即可

我们需要尽可能在高速缓存中去取数据：*

因此我们需要量化CPU从高速缓存中取数据的成功率：【也就是命中率】

**缓存命中率：理论上CPU每次都能从高速缓存中取数据，命中率为1**

这个只是理论上的，**因为高速缓存的容量不如主存，因此永远不能为1** （why???容量和命中率的关系？）

![](C:\Users\fucker\Pictures\jc.20.PNG)

*因为两者都会访问，加起来的才是访问总次数，而命中率=访问高速缓存的速度/访问的总次数  因此永远不会为1*



还有一个量化的指标也可以衡量CPU从高速缓存中取数据的成功率：【访问效率】

![](C:\Users\fucker\Pictures\jc.21.PNG)

访问缓存的平均时间：访问缓存的命中率*访问缓存的时间

访问主存的平均时间：访问主存的命中率*访问主存的时间

整个层次的平均时间：访问主存的平均时间+访问缓存的平均时间

访问效率：e=访问缓存的时间/访问的整个层次的平均时间



![](C:\Users\fucker\Pictures\jc.22.PNG)

平均访问时间为：
$$
0.97*50+(1-0.97)200=54.5ns
$$
**访问主存和访问缓存的速度是不一样的，可能访问了缓存几十次，才访问了主存一次。**

****

我们想要命中率越高越好就需要一个*良好的缓存替换策略*



**高速缓存的替换策略**

**替换的时机：【缓存中没有数据，需要从主存中载入所需的数据】**



**替换的算法：【这几种算法，在其他处理缓存的领域也是常用的】**

1.*随机算法*：【每次随机选取一个高速缓存中的位置，然后把相关的内容替换掉】

**2.先进先出算法(FIFO)：**【把高速缓存看做最先的算法】

*把高速缓存看做是一个先进先出的队列

*优先替换最先进入队列的字块

![](C:\Users\fucker\Pictures\jc.23.PNG)





3.最不经常使用算法(LFU)**：【替换最不经常使用的字块。看标记的频率】

*优先淘汰最不经常使用的字块

*需要额外空间记录每个字块的使用频率

![](C:\Users\fucker\Pictures\jc.24.PNG)

每个缓存中的字块都有一个对应的频率。每次使用频率加1 

然后淘汰时选择最少频率的淘汰

![](C:\Users\fucker\Pictures\jc.25.PNG)





4**.最近最少使用算法(LRU)**：【每次使用，若是缓存中有该字块，则将字块放到最前面，表示它是最近使用的】

和LFU算法产生的结果是很类似的，但区别在：

1.**如果一个子块，先使用很多次，例如1万次，然后连续10多次没有被使用到，那它就被替换了 。**

这个叫卸磨杀驴算法？？？或者说是末位淘汰算法？？？

**2.可以解决访问频率相同的问题**



**优先淘汰一段时间内没有使用的算法*

**有多种实现方式，一般使用双向链表来实现*

*把当前访问节点置于链表前面(保证链表头部节点是最近使用的)*

这里的节点可以是字块。用字块来想这个逻辑会更好理解一点

**每次都是淘汰末位的，只不过再次被使用的字块会放到前面去**

![](C:\Users\fucker\Pictures\jc.26.PNG)



**面试会问替换策略？！**

****

****

### 11.计算机的指令系统--组成篇

**根据这一章的学习标明，毕竟简易的笔记，十分不易于复习**

**1.机器指令形式**

**2.机器指令的操作类型**

**3.机器指令的寻址方式**

****

**机器指令的形式*

操作码，地址码组成

指明指令要完成的 操作

**操作码的位数反映了机器可以做出的操作种类，每一个操作都 对象做着一种操作。操作码的位数实际上只的是操作码总数的位数。只是在计算机领域习惯性的省略了"总数的"这3个字，一般位数都是值总数的位数**

*假如：一个8位的操作码，它可以做出的种类如下*

2^8=256 种

****



**地址码**

*地址码直接给出操作数或者操作数的地址*

**这里的操作数指的是操作的数据**

*分类:1，2，3地址码指令*

3地址码指令，**指的是地址码字段有3个地址**

| 操作码     | 地址码1 | 地址码2 | 地址码3 |
| ---------- | ------- | ------- | ------- |
| 操作码(OP) | addr1   | addr2   | addr3   |

**该条指令所执行的操作：(addr1)OP(addr2)→(addr3)**

*它表示地址1(对应的数据)和地址2(对应的数据)进行了OP操作，然后将值赋给了地址3*

假设：OP是加法操作，那地址1对应的数据就是加数，而地址2对应的数据就是另一个加数，它们进行了加法操作，并用地址3来保存两者的和

**在计算机领域中，只有复制和覆盖**

底层比较简单，**没有特殊的方法，这里的赋值就是覆盖**

这里就是用和这个值**覆盖了地址3原本对应的数据**，那个数据可能对应的是0





2地址码指令，**指的是地址码字段有2个地址**

| 操作码     | 地址码 1 | 地址码2 |
| ---------- | -------- | ------- |
| 操作码(OP) | addr1    | addr2   |

**该条指令所执行的操作：(addr1)OP(addr2)→(addr1)或(addr2)**

*它表示地址1(对应的数据)和地址2(对应的数据)进行了OP操作，然后将值随机赋给了地址1或者是地址2*

逻辑同上，地址1或者地址2对应的数据，被操作之后的数据所覆盖





1地址码指令，指的是地址码字段有1个地址

| 操作码(OP) | 地址码 |
| ---------- | ------ |
| OP         | addr1  |

**该条指令所执行的操作：(addr1)OP→(addr1)     或者是 (addr1)OP(ACC)→(addr1)**

*第一个，它表示地址1(对应的数据)对自身进行了OP操作，然后将得到的值赋给了地址1。也就是原来对应的数据被新的值所覆盖了*

*第2个，可以理解为1个操作数(数据)操作一个默认行为，例如："自增"，它不需要第2个操作数参与*



**零地址指令**

1.在机器指令中无地址码

2.空操作、停机操作、中断返回操作等





****

**机器指令的操作类型**

**数据据传输：**

**寄存器之间，寄存器与存储单元，存储单元(主存，辅助，高速缓存等)之间传输*

**数据读写、交换地址数据、清0置1等*



**算术逻辑操作：**【算术/逻辑运算】

1.操作数之间的加减乘除运算

2.操作数的与、或、非等逻辑位运算



**移位操作**: 【×2，÷2】

1.数据左移(乘2)、数据右移(除2)

2.**完成数据在算术逻辑单元的必要操作**



**控制指令**

**等待指令、停机指令、空操作指令、中断指令等**



****

**机器指令的寻址方式**

**主要的指令寻址方式：**

顺序寻址：一般是

跳跃寻址：顺序的基础之上的

![](C:\Users\fucker\Pictures\jc.27.PNG)

*由指令地址101对应的指令MOV RO,R1所对应的指令开始，按照地址大小，由101→102，再由102→103，再用103→104.........直到执行到105地址对应的指令JMP  102，它又跳转到执行地址102对应的指令*

**前面101~105，属于顺序寻址，后面105跳转到102属于跳跃寻址**



**数据寻址方式：**【分为三种】  寻址指的就是根据机器指令的中的地址找数据

**立即寻址：包含操作数(据)**

机器指令示例：

| 操作码(OP) | 地址码1 | 操作(的)数(据) |
| ---------- | ------- | -------------- |
| OP         | addr1   | 6              |

**直接在机器指令中获得了操作数(据)**



1.指令直接获得操作数

2.无需访问存储器





**直接寻址：操作数(据)在地址**

还是上面那张表，**操作系统读取地址码addr1时，会在主存中寻找addr1这个地址码所对应的数据**

1.直接给出操作数(据)在主存的地址

2.寻找操作数(据)简单，无需计算数据地址(间接寻址需要)







**间接寻址：操作数(据)在地址中的地址**

机器指令示例：

| 操作码 | 地址码1 | 地址码2 |
| ------ | ------- | ------- |
| OP     | R1      | addr1   |

1.指令地址码给出的是操作数地址的地址

2.需要访问一次或者多次主存来获取操作数

*这里addr1这个地址码对应的不是操作数(据)，而是另一条在主存中的地址，根据这条地址，才能在主存中找到操作数(据)*





**三种机器指令的寻址对比 **

| 寻址方式 | 优点           | 缺点                               |
| -------- | -------------- | ---------------------------------- |
| 立即寻址 | 速度快         | 地址码位数**限制操作数表示范围**   |
| 直接寻址 | 寻找操作数简单 | 地址码位数**限制操作数的寻址范围** |
| 间接寻址 | 寻址范围大     | 速度较慢                           |



****

****

### 12.计算机的CPU之控制器--组成篇

![](C:\Users\fucker\Pictures\jc.28.PNG)

程序计数器：存下一条指令的

时序发生器：电子工程领域，电子脉冲

指令译码器：翻译机器指令

指令寄存器：将指令读到寄存器中，和主存或者缓存进行通信

主存地址寄存器：存当前或者将要执行的指令在主存中所对应的地址

主存数据寄存器：存当前或者将要处理的数据

通用寄存器：比一般寄存器大，用于暂时存放数据或者指令（被当作备用的寄存器？？？），**可以用来保存ALU运算的中间结果**

****

****

### 13.计算机的CPU之运算器--组成篇

**概念：运算器是用来进行数据进行数据运算加工的**

**组成：**

**数据缓冲器：【和外设做数据交互】**

1.分为输入缓冲和输出缓冲

**输入缓冲：暂时存放外设送过来的数据，然后将这些数据送往ALU**

如果ALU正在运算，那么下一个需要运算的数据就保存在输入缓冲中

**输出缓冲：暂时出存放ALU送来的数据，然后将这些数据送往外设**

如果数据运算完，从ALU中出来，就先将其保存在ALU中，然后等待控制器的指令，输往相应的位置

**ALU：算术逻辑单元，是运算器的主要组成**

常见的位运算(左右移、与或非等)

算术运算(加减乘除)



**ALU结构图：**







**通用寄存器**：

和控制器中通用寄存器类似

用于暂时存放或传送数据或指令

可保存ALU的运算中间结果

容量比一般专用寄存器要大



**状态字寄存器**：

存放运算状态(条件码、进位、溢出、结果正负)

存放运算控制信息(调试跟踪标记位，允许 中断位)



最后是总线

****

****

### 14.计算机指令的执行过程

步骤：

**取指令>>>分析指令>>>执行指令**

****

****

### 15.进制基础--计算篇

**二进制转十进制：按权展开法：**

*没有一个0就多一次方，1后面6个0就是2的6次方，1后面5个0就是2的5次方*
$$
01100101=01000000+100000+100+1=2^6+2^5+2^2+1=101
$$
**（整数）十进制转二进制：重复相除法**

*这里要注意的就是商为1后，还需要再除1次，知道商为0才算完结*

| 重复除以2 | 得商 | 取余数 |
| --------- | ---- | ------ |
| 101/2     | 50   | 1      |
| 50/2      | 25   | 0      |
| 25/2      | 12   | 1      |
| 12/2      | 6    | 0      |
| 6/2       | 3    | 0      |
| 3/2       | 1    | 1      |
| 1/2       | 0    | 1      |

因此101=1010011



**（小数）十制转二进制：重复相乘法**

最后“提出的值”为0时代表结束

| 重复乘以2 | 得积         | 取1  |
| --------- | ------------ | ---- |
| 25/32     | 50/32=1+9/16 | 1    |
| 9/16      | 18/16=1+1/8  | 1    |
| 1/8       | 1/4=0+1/4    | 0    |
| 1/4       | 1/2=0+1/2    | 0    |
| 1/2       | 1=1+0        | 1    |







****

****

# 计算机基础--操作系统

## 2.进程管理之进程实体

### **为什么需要进程?**

进程是系统进行资源分配和调度和调度的基本单位

进程作为程序独立运行的载体保障程序正常执行

进程存在使得操作系统资源的利用率大幅提升

**多道程序设计**

### **进程的实体**

*主存中的进程形态：*

作为 **进程控制块**的形式存在

以下为一个进程控制块：

| 标识符     ：标识符唯一标记一个进程，用于区别其他进程。例如：进程ID |
| ------------------------------------------------------------ |
| 状态        ：状态这个区域存储的就是【标记进程的进程状态，如：运行态、阻塞状态】 |
| 优先级   ：                                                  |
| 程序计数器 ：CPU中也有类似的设备,功能为【进程即将执行的下一条指令的地址】 |
| 内存指针    ：指的是【程序代码、进程数据相关的指针，一个程序可能存在多个指针】 |
| 上下文数据  ：功能为存储【进程执行时处理器存储的数据，如：寄存器高速缓存中的数据】 |
| IO状态信息  ：功能为存储【被进程IO操作的文件列表】           |
| 记账信息        ：功能为存储【使用处理器时间，时钟总和等】   |
| .............                                                |

总共可以归为4类：

**进程标识，处理机状态，进程调度信息，进程控制信息**



**进程控制块（PCB）：1.用于描述和控制进程运行的通用数据结构**

2.记录进程当前状态和控制进程运行的全部信息

3.PCB的使得进程是能够独立运行的基本单位{每一个进程都依赖进程控制块而被操作系统所调度}

4.PCB是操作系统进行调度经常会读取的信息

5.PCB是常驻内存的，存放在系统专门开辟的PCB区域内



**进程（Process）与线程(Thread)**

进程是**系统进行资源分配和调度的基本的单位**。

线程是**操作系统进行运行调度的最小单位**{操作系统对于进程的调度，实际上是对进程内部的线程调度}，包含在进程之中，**是进程中实际运行工作的单位**。

**一个进程可以并发多个线程，每个线程执行不同的任务。**

（进程中的）**线程共享进程的资源**

****

总结两者进行对比

| 对比的属性 | 进程               | 线程                 |
| ---------- | ------------------ | -------------------- |
| 资源       | 资源分配的基本单位 | 不拥有资源           |
| 调度       | 独立调度的基本单位 | 独立调度的最小单位   |
| 系统开销   | 进程系统开销较大   | 线程系统开销小       |
| 通信       | 进程IPC            | 读写同一进程数据通信 |



## 3.进程管理之无状态模型

**就绪，阻塞，执行**以及创建，终止。共5状态

### 1）就绪状态：

当进程被分配到除CPU以外的所有必要的资源后

*在一个系统中多个处于就绪状态的进程通常排成一个队列*---**就绪队列**

当进程被分配到除CPU以外所有必要的资源后

只要再获得CPU的使用权，就可以立即运行

其他资源都准备好，只差CPU资源的状态为**就绪状态**。

### 2）执行状态：

进程获得CPU，其程序正在执行称为执行状态 

在单处理机(也就是单核CPU)中，**在某一时刻只能有一个进程处于执行状态**

### 3）阻塞状态

当进程因某种原因如：其他设备未就绪而无法继续执行，从而放弃CPU的状态未阻塞状态。

*同样类似于就绪状态，在一个系统中存在多个处于阻塞状态的进程通常排成一个队列*---**阻塞队列**



### 4）创建状态

分配PCB——>插入就绪队列

*创建进程时拥有PCB但**其他资源尚未就绪***的状态被称为创建状态

**操作系统提供fork函数接口创建进程**

### 5）终止状态

系统清理——>PCB归还

进程结束由系统**清理或者归还PCB的状态**称为终止状态

![](C:\Users\fucker\Pictures\jc.29.png)

****

## 4.进程管理之进程同步

### 1）为什么需要进程间的同步？



**生产者和消费者问题**--常见问题之一

![](C:\Users\fucker\Pictures\jc.30.png)

图解生产者和消费者模式

![](C:\Users\fucker\Pictures\jc.31.png)



**错误原因是，两个进程并发执行了，它们同时对缓冲区中的数据进行了操作，导致了数据不一致**



**哲学家进餐的问题**--常见问题之2

![](C:\Users\fucker\Pictures\jc.32.png)

筷子相当于资源，哲学家相当于资源



**两个模型的根源问题是：彼此之间没有通信**

*如果：生产者通知消费者我已经完成了一件生产*

*如果：哲学家向旁边的哲学家说我要进餐了*

**这里，就需要进程间的同步！！  【前面只是并发】**

**它的作用:**

*1.对竞争资源在多进程间进行使用的次序的协调*

*2.使得并发执行的多个进程之间可以有效使用资源和相互合作*

## 2）进程间同步的原则

## 3）线程同步